import librosa
import pandas as pd
import numpy as np
import os
import json
import matplotlib
matplotlib.use('Agg')  # Set non-interactive backend
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib.backends.backend_pdf import PdfPages
from pydub import AudioSegment
import io

# --- CONFIGURATION CONSTANTS ---
APNEA_THRESHOLD_FACTOR = 0.1

def calculate_amplitude_envelope(y, sr):
    """
    Calculates the amplitude envelope by averaging the signal in 1-second segments.

    Args:
        y (np.ndarray): The audio time series.
        sr (int): The sampling rate of the audio.

    Returns:
        pd.DataFrame: A DataFrame with 'Time', 'Positive_Mean', and 'Negative_Mean' columns.
    """
    full_seconds = int(len(y) / sr)
    if full_seconds == 0:
        return pd.DataFrame({'Time': [], 'Positive_Mean': [], 'Negative_Mean': []})
    
    y_truncated = y[:full_seconds * sr]
    segments = y_truncated.reshape((full_seconds, sr))
    
    positive_mean = np.nan_to_num(np.mean(segments, axis=1, where=(segments > 0)))
    negative_mean = np.nan_to_num(np.mean(segments, axis=1, where=(segments < 0)))
    
    time = np.arange(full_seconds)
    return pd.DataFrame({'Time': time, 'Positive_Mean': positive_mean, 'Negative_Mean': negative_mean})

def identify_phase_intervals(apnea_mask, time):
    """
    Identifies and classifies time intervals as inhalation, exhalation, or apnea.

    Args:
        apnea_mask (pd.Series): A boolean mask indicating apnea (True) or non-apnea (False).
        time (pd.Series): The time series corresponding to the apnea_mask.

    Returns:
        dict: A dictionary with lists of [start_time, end_time] for 'inhalation', 'exhalation', and 'apnea'.
    """
    details = {'inhalation': [], 'exhalation': [], 'apnea': []}
    if time.empty:
        return details
        
    # Detect changes in the apnea mask to find phase transitions
    changes = np.diff(apnea_mask.astype(int), prepend=apnea_mask.iloc[0])
    change_points_idx = np.where(changes != 0)[0]
    
    start_idx = 0
    respiration_alternator = True  # True for inhalation, False for exhalation
    
    # Add the end of the mask as a change point to process the last segment
    change_indices = list(change_points_idx) + [len(apnea_mask)]

    for end_idx in change_indices:
        if end_idx == 0: continue
        if start_idx >= len(time): break

        is_apnea = apnea_mask.iloc[start_idx]
        start_time = time.iloc[start_idx]
        # The end time is now the start of the next segment, making it exclusive.
        if end_idx < len(time):
            end_time = time.iloc[end_idx]
        else:
            # For the last segment, the end is the last time point + 1.
            end_time = time.iloc[-1] + 1

        if end_time > start_time:
            if is_apnea:
                details['apnea'].append([start_time, end_time])
            else:
                if respiration_alternator:
                    details['inhalation'].append([start_time, end_time])
                else:
                    details['exhalation'].append([start_time, end_time])
                respiration_alternator = not respiration_alternator
        
        start_idx = end_idx
        
    return details

def phases_to_events(phases):
    """
    Converts the phases dictionary into a sorted list of events.

    Args:
        phases (dict): A dictionary of phase intervals (e.g., {'inhalation': [[s1, e1]], 'apnea': [[s2, e2]]}).

    Returns:
        list: A list of event dictionaries, each with 'id', 'start', 'end', and 'type'.
    """
    events = []
    # Assign a unique ID to each phase for frontend manipulation
    phase_id = 0
    for phase_type, intervals in phases.items():
        for start, end in intervals:
            events.append({'id': phase_id, 'start': int(start), 'end': int(end), 'type': phase_type})
            phase_id += 1
    # Sort by start time
    events.sort(key=lambda x: x['start'])
    return events

def build_respiratory_cycles_table(events):
    """
    Constructs a pandas DataFrame with respiratory cycles and a list of cycle events.
    Cycles must start with an inhalation, ignoring initial apneas.

    Args:
        events (list): A list of event dictionaries, typically generated by `phases_to_events`.

    Returns:
        tuple: A tuple containing:
            - pd.DataFrame: DataFrame of respiratory cycles, including an 'avg' row.
            - list: A list of cycle event dictionaries for visualization.
    """
    cycles_data = []
    cycle_events = []

    # Find the index of the first inhalation event to start the search.
    try:
        search_start_index = next(i for i, event in enumerate(events) if event['type'] == 'inhalation')
    except StopIteration:
        # If no inhalations, no cycles can be formed.
        return pd.DataFrame(columns=['Cycle', 'Inhalation (s)', 'Apnea 1 (s)', 'Exhalation (s)', 'Apnea 2 (s)', 'Total Cycle (s)']), []

    i = search_start_index
    cycle_num = 1
    while i <= len(events) - 4:
        # A canonical respiratory cycle is Inhalation -> Apnea -> Exhalation -> Apnea
        e1, e2, e3, e4 = events[i:i+4]
        if (e1['type'] == 'inhalation' and 
            e2['type'] == 'apnea' and 
            e3['type'] == 'exhalation' and 
            e4['type'] == 'apnea'):
            
            current_cycle = {
                'Cycle': cycle_num,
                'Inhalation (s)': e1['end'] - e1['start'],
                'Apnea 1 (s)': e2['end'] - e2['start'],
                'Exhalation (s)': e3['end'] - e3['start'],
                'Apnea 2 (s)': e4['end'] - e4['start']
            }
            current_cycle['Total Cycle (s)'] = sum(list(current_cycle.values())[1:])
            cycles_data.append(current_cycle)
            
            cycle_events.append({
                'id': f'cycle_{cycle_num}',
                'start': e1['start'],
                'end': e4['end'],
                'label': f'{cycle_num}',
                'cycle_number': cycle_num
            })
            
            cycle_num += 1
            i += 4  # Advance to the next potential cycle
        else:
            i += 1  # Try the next sequence
            
    if not cycles_data:
        return pd.DataFrame(columns=['Cycle', 'Inhalation (s)', 'Apnea 1 (s)', 'Exhalation (s)', 'Apnea 2 (s)', 'Total Cycle (s)']), []
    
    df_cycles = pd.DataFrame(cycles_data)
    averages = df_cycles.drop(columns='Cycle').mean().round(2)
    averages['Cycle'] = 'avg'
    df_cycles = pd.concat([df_cycles, pd.DataFrame([averages])], ignore_index=True)
    
    return df_cycles, cycle_events

# --- Respiration Analysis Functions ---

CONFIG = {
    "TARGET_CYCLE_DURATION": 20.0,  # 12s = 5 RPM, 20s = 3 RPM
    "TARGET_IE_RATIO": 3,   # Exhalation / Inhalation Ratio
    "TARGET_APNEA_PERCENTAGE": 0.5,   # Percentage of cycle dedicated to apneas
    "PILLAR_WEIGHTS": {
        "depth": 0.3,
        "stability": 0.4,
        "balance": 0.3
    },
    "PHASE_STABILITY_WEIGHTS": {
        'inh': 0.40, 'exh': 0.40, 'ap1': 0.10, 'ap2': 0.10
    },
    "INTERNAL_BALANCE_WEIGHTS": {
        'ie_ratio': 0.7, 'apnea_control': 0.3
    }
}

PHASE_COLUMNS = ['Inhalation (s)', 'Apnea 1 (s)', 'Exhalation (s)', 'Apnea 2 (s)']

def calculate_depth_score(df, config):
    """
    Calculates the depth score based on the average total cycle duration.

    Args:
        df (pd.DataFrame): DataFrame of respiratory cycles (excluding 'avg' row).
        config (dict): A dictionary containing scoring parameters.

    Returns:
        float: The depth score (0-100).
    """
    avg_cycle_duration = df['Total Cycle (s)'].mean()
    score = min(1.0, avg_cycle_duration / config["TARGET_CYCLE_DURATION"]) * 100
    return score

def calculate_stability_score(df, config):
    """
    Calculates the stability score based on the consistency of each phase duration.

    Args:
        df (pd.DataFrame): DataFrame of respiratory cycles (excluding 'avg' row).
        config (dict): A dictionary containing scoring parameters.

    Returns:
        float: The weighted average stability score (0-100).
    """
    stability_scores = {}
    weights = config["PHASE_STABILITY_WEIGHTS"]

    for phase, col_name in zip(weights.keys(), PHASE_COLUMNS):
        mean_val = df[col_name].mean()
        std_dev = df[col_name].std()
        cv = (std_dev / mean_val) if mean_val > 0 else 0
        stability_scores[phase] = max(0, 1 - cv) * 100

    final_weighted_score = sum(weights[phase] * stability_scores[phase] for phase in weights)
    return final_weighted_score

def calculate_balance_score(df, config):
    """
    Calculates the internal balance score based on inhalation/exhalation ratio and apnea control.

    Args:
        df (pd.DataFrame): DataFrame of respiratory cycles (excluding 'avg' row).
        config (dict): A dictionary containing scoring parameters.

    Returns:
        float: The weighted average internal balance score (0-100).
    """
    weights = config["INTERNAL_BALANCE_WEIGHTS"]

    mean_inh = df['Inhalation (s)'].mean()
    mean_exh = df['Exhalation (s)'].mean()
    actual_ie_ratio = (mean_exh / mean_inh) if mean_inh > 0 else 0
    ie_ratio_score = max(0, 1 - abs(actual_ie_ratio - config["TARGET_IE_RATIO"]) / config["TARGET_IE_RATIO"]) * 100

    mean_ap1 = df['Apnea 1 (s)'].mean()
    mean_ap2 = df['Apnea 2 (s)'].mean()
    mean_cycle = df['Total Cycle (s)'].mean()
    actual_apnea_percentage = ((mean_ap1 + mean_ap2) / mean_cycle) if mean_cycle > 0 else 0
    apnea_control_score = max(0, 1 - abs(actual_apnea_percentage - config["TARGET_APNEA_PERCENTAGE"]) / config["TARGET_APNEA_PERCENTAGE"]) * 100

    final_weighted_score = (weights['ie_ratio'] * ie_ratio_score + weights['apnea_control'] * apnea_control_score)
    return final_weighted_score

def analyze_respiration(df_cycles, custom_config=None):
    """
    Analyzes respiratory cycles and provides scores and recommendations.

    Args:
        df_cycles (pd.DataFrame): DataFrame of respiratory cycles, including the 'avg' row.
        custom_config (dict, optional): A dictionary with custom scoring parameters to override defaults.

    Returns:
        dict: A dictionary containing scores, number of cycles, weakest pillar, and recommendation,
              or None if there's insufficient data.
    """
    if df_cycles.empty or 'avg' not in df_cycles['Cycle'].values:
        return None

    # Merge custom config with default config
    final_config = CONFIG.copy()
    if custom_config:
        final_config.update(custom_config)

    # Exclude the 'avg' row for score calculations
    df = df_cycles[df_cycles['Cycle'] != 'avg'].copy()
    if df.empty:
        return None

    depth_score = calculate_depth_score(df, final_config)
    stability_score = calculate_stability_score(df, final_config)
    balance_score = calculate_balance_score(df, final_config)

    weights = final_config["PILLAR_WEIGHTS"]
    final_score = (weights['depth'] * depth_score +
                   weights['stability'] * stability_score +
                   weights['balance'] * balance_score)

    scores = {
        'Depth': depth_score,
        'Stability': stability_score,
        'Internal Balance': balance_score,
        'Final': final_score
    }

    # Identify the weakest pillar (excluding the 'Final' score)
    weakest_pillar = min({k: v for k, v in scores.items() if k != 'Final'}, key=scores.get)
    
    recommendations = {
        "Depth": "Try to breathe slower and deeper (breaths per minute).",
        "Stability": "Focus on maintaining a consistent rhythm in each phase.",
        "Internal Balance": "Work on the structure of your breath (e.g., longer exhalation and/or apneas)."
    }

    return {
        "scores": {k: f"{v:.2f}" for k, v in scores.items()},
        "num_cycles": len(df),
        "weakest_pillar": weakest_pillar,
        "recommendation": recommendations[weakest_pillar]
    }

def generate_cycles_html_table(events):
    """
    Generates the HTML code for the respiratory cycles table and returns cycle events.

    Args:
        events (list): A list of event dictionaries.

    Returns:
        tuple: A tuple containing:
            - str: HTML string of the cycles table.
            - list: A list of cycle event dictionaries.
    """
    if not events:
        return "<p>No phase data available to generate the table.</p>", []
    df_table, cycle_events = build_respiratory_cycles_table(events)
    if df_table.empty:
        return "<p>No complete respiratory cycles detected.</p>", []
    return df_table.to_html(classes='table table-striped', index=False), cycle_events

def calculate_waveshow_data(y, sr, num_vis_points=1000):
    """
    Calculates data for a waveshow-like visualization (min/max envelope).

    Args:
        y (np.ndarray): The audio time series.
        sr (int): The sampling rate of the audio.
        num_vis_points (int): The number of visualization points for the waveshow.

    Returns:
        tuple: A tuple containing:
            - list: Time axis for the waveshow.
            - list: Minimum amplitude values for each frame.
            - list: Maximum amplitude values for each frame.
    """
    # Ensure y is a numpy array for easier reshaping
    y = np.array(y)
    
    # Calculate the size of each frame
    frame_size = len(y) // num_vis_points
    
    # Truncate y so it's divisible by the number of points
    y_truncated = y[:num_vis_points * frame_size]
    
    # Reshape to group into frames
    y_frames = y_truncated.reshape(num_vis_points, frame_size)
    
    # Calculate min and max for each frame
    y_min = y_frames.min(axis=1)
    y_max = y_frames.max(axis=1)
    
    # Create the corresponding time axis
    t_wave = np.linspace(0, len(y) / sr, num_vis_points)
    
    return t_wave.tolist(), y_min.tolist(), y_max.tolist()

def save_analysis_results(output_dir, events, df_table, analysis_data, respiration_analysis, export_format='all'):
    """
    Saves comprehensive analysis results including original and adjusted spectrograms, 
    detailed reports, and data tables in multiple formats.

    Args:
        output_dir (str): The directory to save the results.
        events (list): The list of phase events (current/adjusted).
        df_table (pd.DataFrame): The respiratory cycles table.
        analysis_data (dict): The dictionary with all analysis data.
        respiration_analysis (dict): The dictionary with respiration analysis scores.
        export_format (str): Export format - 'pdf', 'png', 'csv', 'excel', or 'all'.
    """
    os.makedirs(output_dir, exist_ok=True)

    # Check if we have sufficient data for analysis
    has_cycle_data = not df_table.empty and len(df_table) > 0
    has_events = len(events) > 0

    # --- Save Respiratory Cycles Table in Multiple Formats ---
    if export_format in ['csv', 'all']:
        table_path = os.path.join(output_dir, 'respiratory_cycles.csv')
        if has_cycle_data:
            df_table.to_csv(table_path, index=False)
        else:
            # Create a basic table with available events
            simple_df = pd.DataFrame([{
                'Event_ID': event['id'],
                'Type': event['type'], 
                'Start_Time': event['start'],
                'End_Time': event['end'],
                'Duration': event['end'] - event['start']
            } for event in events])
            simple_df.to_csv(table_path, index=False)
    
    if export_format in ['excel', 'all']:
        try:
            excel_path = os.path.join(output_dir, 'respiratory_cycles.xlsx')
            if has_cycle_data:
                df_table.to_excel(excel_path, index=False, sheet_name='Respiratory_Cycles')
            else:
                simple_df = pd.DataFrame([{
                    'Event_ID': event['id'],
                    'Type': event['type'], 
                    'Start_Time': event['start'],
                    'End_Time': event['end'],
                    'Duration': event['end'] - event['start']
                } for event in events])
                simple_df.to_excel(excel_path, index=False, sheet_name='Events')
        except ImportError:
            # Fallback to CSV if openpyxl is not available
            if export_format == 'excel':
                table_path = os.path.join(output_dir, 'respiratory_cycles.csv')
                if has_cycle_data:
                    df_table.to_csv(table_path, index=False)
                else:
                    simple_df = pd.DataFrame([{
                        'Event_ID': event['id'],
                        'Type': event['type'], 
                        'Start_Time': event['start'],
                        'End_Time': event['end'],
                        'Duration': event['end'] - event['start']
                    } for event in events])
                    simple_df.to_csv(table_path, index=False)

    # --- Handle cycle events safely ---
    try:
        _, cycle_events = build_respiratory_cycles_table(events)
    except Exception:
        cycle_events = []

    # --- Enrich events with cycle number and save for ML ---
    enriched_events = []
    for event in events:
        enriched_event = event.copy()
        # Find which cycle this event belongs to
        for cycle in cycle_events:
            if cycle['start'] <= event['start'] and event['end'] <= cycle['end']:
                enriched_event['cycle_number'] = cycle['cycle_number']
                break
        if 'cycle_number' not in enriched_event:
            enriched_event['cycle_number'] = None
        enriched_events.append(enriched_event)

    segmentation_data = {
        "audio_metadata": {
            "original_filename": analysis_data.get("filename", "unknown"),
            "total_duration_seconds": analysis_data.get("duration", 0),
            "sampling_rate": analysis_data.get("sampling_rate", 0),
            "total_events_detected": len(events),
            "total_cycles_detected": len(cycle_events)
        },
        "segmentation_events": [
            {
                "start_time": float(event['start']),
                "end_time": float(event['end']),
                "label": event['type'],
                "cycle_number": event.get('cycle_number', None)
            } for event in enriched_events
        ]
    }
    
    if export_format in ['csv', 'excel', 'all']:
        json_path = os.path.join(output_dir, 'final_analysis_report.json')
        with open(json_path, 'w') as f:
            json.dump(segmentation_data, f, indent=4)

    # Define phase colors for consistent visualization
    phase_colors = {
        'inhalation': 'green',
        'exhalation': 'orange', 
        'apnea': 'red'
    }

    # --- Generate Original and Adjusted Spectrograms ---
    original_events = analysis_data.get('original_events', events)  # Fallback to current if no original stored
    
    def create_spectrogram_plot(events_to_plot, title_suffix, ax1, ax2):
        """Helper function to create consistent spectrogram plots"""
        try:
            # Plot 1: Audio Signal
            if 'signal' in analysis_data and analysis_data['signal']:
                ax1.fill_between(analysis_data['signal']['t'], analysis_data['signal']['min'], 
                                analysis_data['signal']['max'], color='gray', alpha=0.5, label='Audio Signal')
            ax1.set_ylabel('Amplitude')
            ax1.set_title(f'Audio Signal and Segmentation - {title_suffix}')
            ax1.grid(True, alpha=0.3)
            ax1.legend(loc='upper right')

            # Plot 2: Breathing Envelope and Phases
            if 'envelope' in analysis_data and analysis_data['envelope']:
                ax2.plot(analysis_data['envelope']['time'], analysis_data['envelope']['positive_mean'], 
                        label='Positive Envelope', color='blue', linewidth=1.5)
                ax2.plot(analysis_data['envelope']['time'], analysis_data['envelope']['negative_mean'], 
                        label='Negative Envelope', color='purple', linewidth=1.5)
            
            ax2.set_xlabel('Time (s)')
            ax2.set_ylabel('Mean Amplitude')
            ax2.grid(True, alpha=0.3)

            # Add phase rectangles if we have valid y-limits
            if len(events_to_plot) > 0:
                ylim = ax2.get_ylim()
                if ylim[1] > ylim[0]:  # Valid y-limits
                    for event in events_to_plot:
                        ax2.add_patch(Rectangle((event['start'], ylim[0]), 
                                               event['end'] - event['start'], 
                                               ylim[1] - ylim[0], 
                                               color=phase_colors.get(event['type'], 'gray'), 
                                               alpha=0.3))

            # Add cycle numbers if available
            if cycle_events:
                for cycle in cycle_events:
                    ax2.text(cycle['start'], ax2.get_ylim()[1] * 0.9, f" {cycle['label']}", 
                            color='blue', fontsize=10, ha='left', va='top', weight='bold')

            # Enhanced color legend
            handles = [Rectangle((0,0),1,1, color=color, alpha=0.3) for color in phase_colors.values()]
            labels = [f'{phase.title()} Phase' for phase in phase_colors.keys()]
            legend_elements = handles + [plt.Line2D([0], [0], color='blue', linewidth=1.5),
                                       plt.Line2D([0], [0], color='purple', linewidth=1.5)]
            legend_labels = labels + ['Positive Envelope', 'Negative Envelope']
            ax2.legend(legend_elements, legend_labels, loc='lower right', fontsize=9)
        
        except Exception as e:
            # Fallback: create simple plot with error message
            ax1.text(0.5, 0.5, f'Error creating plot: {str(e)}', 
                    transform=ax1.transAxes, ha='center', va='center')
            ax2.text(0.5, 0.5, f'Insufficient data for visualization', 
                    transform=ax2.transAxes, ha='center', va='center')

    # --- Create Comprehensive PDF Report ---
    if export_format in ['pdf', 'all']:
        pdf_path = os.path.join(output_dir, 'comprehensive_breathing_analysis_report.pdf')
        with PdfPages(pdf_path) as pdf:
            # Page 1: Original Analysis
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 10), sharex=True)
            create_spectrogram_plot(original_events, "Original Analysis", ax1, ax2)
            plt.suptitle('Breathing Analysis Report - Original Detection', fontsize=16, fontweight='bold')
            plt.tight_layout()
            pdf.savefig(fig, bbox_inches='tight')
            plt.close(fig)

            # Page 2: Adjusted Analysis (if different from original)
            if original_events != events:
                fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 10), sharex=True)
                create_spectrogram_plot(events, "Manually Adjusted", ax1, ax2)
                plt.suptitle('Breathing Analysis Report - Manually Adjusted', fontsize=16, fontweight='bold')
                plt.tight_layout()
                pdf.savefig(fig, bbox_inches='tight')
                plt.close(fig)

            # Page 3: Respiratory Cycles Summary Table
            if has_cycle_data:
                fig_table, ax_table = plt.subplots(figsize=(11, 8))
                ax_table.axis('tight')
                ax_table.axis('off')
                
                table = ax_table.table(cellText=df_table.values, colLabels=df_table.columns, 
                                       cellLoc='center', loc='center')
                table.auto_set_font_size(False)
                table.set_fontsize(10)
                table.scale(1.2, 1.5)

                for (row, col), cell in table.get_celld().items():
                    if row == 0:
                        cell.set_facecolor('#4CAF50')
                        cell.set_text_props(weight='bold', color='white')
                
                plt.suptitle('Respiratory Cycles Summary', fontsize=16, fontweight='bold', y=0.92)
                pdf.savefig(fig_table, bbox_inches='tight')
                plt.close(fig_table)

            # Page 4: Analysis Summaries
            fig_summary, ax_summary = plt.subplots(figsize=(11, 8))
            ax_summary.axis('off')
            
            summary_text = f"""
            Analysis Summary:
            • Total Duration: {analysis_data.get('duration', 0):.1f} seconds
            • Total Events Detected: {len(events)}
            • Total Breathing Cycles: {len(cycle_events)}
            • Sampling Rate: {analysis_data.get('sampling_rate', 0)} Hz
            • File: {analysis_data.get('filename', 'unknown')}
            """
            ax_summary.text(0.05, 0.75, summary_text, transform=ax_summary.transAxes, fontsize=12, 
                           verticalalignment='top', bbox=dict(boxstyle="round,pad=0.4", facecolor="#f0f0f0", alpha=1))

            if respiration_analysis:
                scores = respiration_analysis['scores']
                analysis_text = f"""
                Respiration Analysis:

                • Final Score: {scores['Final']} / 100
                • Depth Score: {scores['Depth']} / 100
                • Stability Score: {scores['Stability']} / 100
                • Internal Balance: {scores['Internal Balance']} / 100

                • Weakest Pillar: {respiration_analysis['weakest_pillar']}
                • Recommendation: {respiration_analysis['recommendation']}
                """
                ax_summary.text(0.05, 0.5, analysis_text, transform=ax_summary.transAxes, fontsize=12, 
                               verticalalignment='top', bbox=dict(boxstyle="round,pad=0.4", facecolor="#e6f7ff", alpha=1))
            
            plt.suptitle('Analysis & Respiration Summary', fontsize=16, fontweight='bold', y=0.92)
            pdf.savefig(fig_summary, bbox_inches='tight')
            plt.close(fig_summary)

    # --- Save Individual PNG Images ---
    if export_format in ['png', 'all']:
        # Original spectrogram
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 8), sharex=True)
        create_spectrogram_plot(original_events, "Original Analysis", ax1, ax2)
        plt.suptitle('Original Breathing Analysis', fontsize=14, fontweight='bold')
        plt.tight_layout()
        original_chart_path = os.path.join(output_dir, 'original_spectrogram.png')
        plt.savefig(original_chart_path, dpi=300, bbox_inches='tight')
        plt.close(fig)

        # Adjusted spectrogram (if different)
        if original_events != events:
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 8), sharex=True)
            create_spectrogram_plot(events, "Manually Adjusted", ax1, ax2)
            plt.suptitle('Adjusted Breathing Analysis', fontsize=14, fontweight='bold')
            plt.tight_layout()
            adjusted_chart_path = os.path.join(output_dir, 'adjusted_spectrogram.png')
            plt.savefig(adjusted_chart_path, dpi=300, bbox_inches='tight')
            plt.close(fig)

        # Legacy chart for compatibility
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 8), sharex=True)
        create_spectrogram_plot(events, "Current Analysis", ax1, ax2)
        plt.tight_layout()
        chart_path = os.path.join(output_dir, 'segmentation_chart.png')
        plt.savefig(chart_path, dpi=300, bbox_inches='tight')
        plt.close(fig)

def _load_audio_file(audio_file_path):
    """
    Loads an audio file, converting MP3 to WAV in memory if necessary.

    Args:
        audio_file_path (str): The path to the audio file.

    Returns:
        tuple: A tuple containing:
            - np.ndarray: The audio time series (y).
            - int: The sampling rate (sr).
    """
    if audio_file_path.lower().endswith('.mp3'):
        # Convert MP3 to WAV in memory to ensure compatibility
        audio = AudioSegment.from_mp3(audio_file_path)
        wav_io = io.BytesIO()
        audio.export(wav_io, format="wav")
        wav_io.seek(0)
        y, sr = librosa.load(wav_io, sr=None)
    else:
        # Load other formats directly
        y, sr = librosa.load(audio_file_path, sr=None)
    return y, sr

def perform_initial_analysis(audio_file_path, apnea_threshold_factor=APNEA_THRESHOLD_FACTOR):
    """
    Main function to analyze the audio. It does not generate visualizations,
    only extracts the necessary data for the interface.

    Args:
        audio_file_path (str): The absolute path to the audio file.
        apnea_threshold_factor (float): The factor to determine the apnea detection threshold.

    Returns:
        tuple: A tuple containing:
            - dict: Analysis data (duration, signal, envelope, events, cycle_events) if successful.
            - str: An error message if an error occurred, otherwise None.
    """
    try:
        y, sr = _load_audio_file(audio_file_path)
        filename = os.path.basename(audio_file_path)
        duration = len(y) / sr

        # Generate data for waveshow visualization
        t_wave, y_min, y_max = calculate_waveshow_data(y, sr)

        df_envelope = calculate_amplitude_envelope(y, sr)
        if df_envelope.empty:
            return None, "Audio duration is too short to be analyzed."

        # Apnea detection based on threshold
        positive_mean_max = df_envelope['Positive_Mean'].dropna().max()
        negative_mean_min = df_envelope['Negative_Mean'].dropna().min()
        amplitude_max = max(positive_mean_max if pd.notna(positive_mean_max) else 0, abs(negative_mean_min) if pd.notna(negative_mean_min) else 0)
        apnea_threshold = amplitude_max * apnea_threshold_factor
        
        apnea_mask = (df_envelope['Positive_Mean'].fillna(0) < apnea_threshold) & \
                     (np.abs(df_envelope['Negative_Mean'].fillna(0)) < apnea_threshold)

        # Get phases and convert them to a list of events
        detected_phases = identify_phase_intervals(apnea_mask, df_envelope['Time'])
        events = phases_to_events(detected_phases)

        # Generate table and get cycle events
        _, cycle_events = build_respiratory_cycles_table(events)

        # Prepare data to send as JSON
        analysis_data = {
            "duration": duration,
            "sampling_rate": sr,
            "filename": filename,
            "signal": {
                "t": t_wave,
                "min": y_min,
                "max": y_max
            },
            "envelope": {
                "time": df_envelope['Time'].tolist(),
                "positive_mean": df_envelope['Positive_Mean'].tolist(),
                "negative_mean": df_envelope['Negative_Mean'].tolist()
            },
            "events": events,
            "cycle_events": cycle_events
        }
        
        return analysis_data, None

    except Exception as e:
        return None, f"An error occurred while processing the file: {e}"
